?t
?colnames
?row.names
?rownames
dir_vec <- list.files(data_directory, recursive = TRUE)
library(RSQLite)
library(DBI)
# Directory for data folder
data_directory <- 'C:/Airbnb'
# Directory and file for SQLite database
sqlite_directory <- 'C:/SQLite/Databases/Airbnb.sqlite3'
# Connect to or create SQLite database
abnb_db <- dbConnect(SQLite(), sqlite_directory)
# Check if tables exist
calendar_exist <- dbExistsTable(abnb_db, 'Calendar')
listings_exist <- dbExistsTable(abnb_db, 'Listings')
reviews_exist <- dbExistsTable(abnb_db, 'Reviews')
map_data_exist <- dbExistsTable(abnb_db, 'Map_DataScrape')
# Create tables if they do not exist
if (calendar_exist == FALSE) {
calendar_create <- 'CREATE TABLE Calendar (
Calendar_ID INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL UNIQUE,
DataScrape_ID INTEGER NOT NULL,
ListingID INTEGER NOT NULL,
Date DATE NOT NULL,
Available VARCHAR NOT NULL,
Price REAL NOT NULL
);
'
dbExecute(abnb_db, calendar_create)
}
if (listings_exist == FALSE) {
listings_create <- 'CREATE TABLE Listings (
Listings_ID INTEGER PRIMARY KEY AUTOINCREMENT UNIQUE NOT NULL,
DataScrape_ID INTEGER NOT NULL,
ID INTEGER NOT NULL,
ListingURL VARCHAR NOT NULL,
ScrapeID INTEGER NOT NULL,
LastSearched DATE NOT NULL,
LastScraped DATE NOT NULL,
Name TEXT NOT NULL,
Summary TEXT NOT NULL,
Space TEXT NOT NULL,
Description TEXT NOT NULL,
ExperiencesOffered TEXT NOT NULL,
NeighborhoodOverview TEXT NOT NULL,
Notes TEXT NOT NULL,
Transit TEXT NOT NULL,
Access TEXT NOT NULL,
Interaction TEXT NOT NULL,
HouseRules TEXT NOT NULL,
ThumbnailURL VARCHAR NOT NULL,
MediumURL VARCHAR NOT NULL,
PictureURL VARCHAR NOT NULL,
XLPictureURL VARCHAR NOT NULL,
HostID INTEGER NOT NULL,
HostURL VARCHAR NOT NULL,
HostName VARCHAR NOT NULL,
HostSince DATE NOT NULL,
HostLocation VARCHAR NOT NULL,
HostAbout TEXT NOT NULL,
HostResponseTime VARCHAR NOT NULL,
HostResponseRate REAL NOT NULL,
HostAcceptanceRate REAL NOT NULL,
HostIsSuperhost VARCHAR NOT NULL,
HostThumbnailURL VARCHAR NOT NULL,
HostPictureURL VARCHAR NOT NULL,
HostNeighborhood VARCHAR NOT NULL,
HostListingsCount INTEGER NOT NULL,
HostTotalListingsCount INTEGER NOT NULL,
HostVerifications VARCHAR NOT NULL,
HostHasProfilePic VARCHAR NOT NULL,
HostIdentityVerified VARCHAR NOT NULL,
Street VARCHAR NOT NULL,
Neighborhood VARCHAR NOT NULL,
NeighborhoodCleansed VARCHAR NOT NULL,
NeighborhoodGroupCleansed VARCHAR NOT NULL,
City VARCHAR NOT NULL,
State VARCHAR NOT NULL,
ZipCode VARCHAR NOT NULL,
Market VARCHAR NOT NULL,
SmartLocation VARCHAR NOT NULL,
CountryCode VARCHAR NOT NULL,
Country VARCHAR NOT NULL,
Latitude VARCHAR NOT NULL,
Longitude VARCHAR NOT NULL,
IsLocationExact VARCHAR NOT NULL,
PropertyType VARCHAR NOT NULL,
RoomType VARCHAR NOT NULL,
Accommodates INTEGER NOT NULL,
Bathrooms INTEGER NOT NULL,
Bedrooms INTEGER NOT NULL,
Beds INTEGER NOT NULL,
BedType VARCHAR NOT NULL,
Amenities VARCHAR NOT NULL,
SquareFeet REAL NOT NULL,
Price REAL NOT NULL,
WeeklyPrice REAL NOT NULL,
MonthlyPrice REAL NOT NULL,
SecurityDeposit REAL NOT NULL,
CleaningFee REAL NOT NULL,
GuestsIncluded INTEGER NOT NULL,
ExtraPeople REAL NOT NULL,
MinimumNights INTEGER NOT NULL,
MaximumNights INTEGER NOT NULL,
CalendarUpdated VARCHAR NOT NULL,
HasAvailability VARCHAR NOT NULL,
Availability30 INTEGER NOT NULL,
Availability60 INTEGER NOT NULL,
Availability90 INTEGER NOT NULL,
Availability365 INTEGER NOT NULL,
CalendarLastScraped DATE NOT NULL,
NumberOfReviews INTEGER NOT NULL,
FirstReview DATE NOT NULL,
LastReview DATE NOT NULL,
ReviewScoresRating INTEGER NOT NULL,
ReviewScoresAccuracy INTEGER NOT NULL,
ReviewScoresCleanliness INTEGER NOT NULL,
ReviewScoresCheckIn INTEGER NOT NULL,
ReviewScoresCommunication INTEGER NOT NULL,
ReviewScoresLocation INTEGER NOT NULL,
ReviewScoresValue INTEGER NOT NULL,
RequiresLicense VARCHAR NOT NULL,
License VARCHAR NOT NULL,
JurisdictionNames VARCHAR NOT NULL,
InstantBookable VARCHAR NOT NULL,
CancellationPolicy VARCHAR NOT NULL,
RequireGuestProfilePicture VARCHAR NOT NULL,
RequireGuestPhoneVerification VARCHAR NOT NULL,
RegionID INTEGER NOT NULL,
RegionName VARCHAR NOT NULL,
RegionParentID INTEGER NOT NULL,
CalculatedHostListingsCount INTEGER NOT NULL,
ReviewsPerMonth REAL NOT NULL
);
'
dbExecute(abnb_db, listings_create)
}
if (reviews_exist == FALSE) {
reviews_create <- 'CREATE TABLE Reviews (
Reviews_ID INTEGER PRIMARY KEY AUTOINCREMENT UNIQUE NOT NULL,
DataScrape_ID INTEGER NOT NULL,
ListingID INTEGER NOT NULL,
ID INTEGER NOT NULL,
Date DATE NOT NULL,
ReviewerID INTEGER NOT NULL,
ReviewerName VARCHAR NOT NULL,
Comments TEXT NOT NULL
);
'
dbExecute(abnb_db, reviews_create)
}
if (map_data_exist == FALSE) {
map_data_create <- 'CREATE TABLE Map_DataScrape (
DataScrape_ID INTEGER PRIMARY KEY AUTOINCREMENT UNIQUE NOT NULL,
Country VARCHAR NOT NULL,
State VARCHAR NOT NULL,
City VARCHAR NOT NULL,
DataScrapeDate DATE NOT NULL
);
'
dbExecute(abnb_db, map_data_create)
}
dir_vec <- list.files(data_directory, recursive = TRUE)
dir_df <- t(data.frame(strsplit(dir_vec, split = '/'), stringsAsFactors = FALSE))
dir_df <- unique(dir_df[, 1:4])
colnames(dir_df) <- c('Country', 'State', 'City', 'DataScrapeDate')
rownames(dir_df) <- seq.int(1, nrow(dir_df))
head(dir_df, 10)
unique(dir_df$City)
class(dir_df)
unique(dir_df[3])
unique(dir_df[, 3])
dir_vec
curs <- abnb_db.cursor()
dbExecute('SELECT MAX(DataScrape_ID) FROM Map_DataScrape')
dbExecute(abnb_db'SELECT MAX(DataScrape_ID) FROM Map_DataScrape')
dbExecute(abnb_db, 'SELECT MAX(DataScrape_ID) FROM Map_DataScrape')
dir_vec <- list.files(data_directory, recursive = TRUE)
dir_df <- t(data.frame(strsplit(dir_vec, split = '/'), stringsAsFactors = FALSE))
dir_df <- unique(dir_df[, 1:4])
colnames(dir_df) <- c('Country', 'State', 'City', 'DataScrapeDate')
# Find max data scrape ID already in the SQLite database
max_scrape <- dbExecute(abnb_db, 'SELECT MAX(DataScrape_ID) FROM Map_DataScrape;')
rownames(dir_df) <- seq.int(max_scrape + 1, max_scrape + nrow(dir_df))
head(dir_df, 10)
dir_vec <- list.files(data_directory, recursive = TRUE)
dir_df <- t(data.frame(strsplit(dir_vec, split = '/'), stringsAsFactors = FALSE))
dir_df <- unique(dir_df[, 1:4])
colnames(dir_df) <- c('Country', 'State', 'City', 'DataScrapeDate')
rownames(dir_df) <- seq.int(1, nrow(dir_df))
head(dir_df, 10)
# Find max data scrape ID already in the SQLite database
max_scrape <- dbExecute(abnb_db, 'SELECT MAX(DataScrape_ID) FROM Map_DataScrape;')
?data.frame
# Disconnect from SQLite database
dbDisconnect(abnb_db)
getwd()
class(NA)
class(BLAH)
class(TRUE)
?object.exists
?object
?objects
?rm
# Disconnect from SQLite database
dbDisconnect(abnb_db)
# Disconnect from SQLite database
dbDisconnect(abnb_db)
# Possible column names for listings data from gz source files
listings_ds_colnames <- c('Listings_ID', 'DataScrape_ID', 'id', 'listing_url', 'scrape_id', 'last_searched',
'last_scraped', 'name', 'summary', 'space', 'description', 'experiences_offered',
'neighborhood_overview', 'notes', 'transit', 'access', 'interaction', 'house_rules',
'thumbnail_url', 'medium_url', 'picture_url', 'xl_picture_url', 'host_id',
'host_url', 'host_name', 'host_since', 'host_location', 'host_about',
'host_response_time', 'host_response_rate', 'host_acceptance_rate',
'host_is_superhost', 'host_thumbnail_url', 'host_picture_url', 'host_neighbourhood',
'host_listings_count', 'host_total_listings_count', 'host_verifications',
'host_has_profile_pic', 'host_identity_verified', 'street', 'neighbourhood',
'neighbourhood_cleansed', 'neighbourhood_group_cleansed', 'city', 'state',
'zipcode', 'market', 'smart_location', 'country_code', 'country', 'latitude',
'longitude', 'is_location_exact', 'property_type', 'room_type', 'accommodates',
'bathrooms', 'bedrooms', 'beds', 'bed_type', 'amenities', 'square_feet', 'price',
'weekly_price', 'monthly_price', 'security_deposit', 'cleaning_fee',
'guests_included', 'extra_people', 'minimum_nights', 'maximum_nights',
'calendar_updated', 'has_availability', 'availability_30', 'availability_60',
'availability_90', 'availability_365', 'calendar_last_scraped', 'number_of_reviews',
'first_review', 'last_review', 'review_scores_rating', 'review_scores_accuracy',
'review_scores_cleanliness', 'review_scores_checkin', 'review_scores_communication',
'review_scores_location', 'review_scores_value', 'requires_license', 'license',
'jurisdiction_names', 'instant_bookable', 'cancellation_policy',
'require_guest_profile_picture', 'require_guest_phone_verification', 'region_id',
'region_name', 'region_parent_id', 'calculated_host_listings_count',
'reviews_per_month')
# Column names for listings data from the SQLite database
listings_db_colnames <- c('Listings_ID', 'DataScrape_ID', 'ID', 'ListingURL', 'ScrapeID', 'LastSearched',
'LastScraped', 'Name', 'Summary', 'Space', 'Description', 'ExperiencesOffered',
'NeighborhoodOverview', 'Notes', 'Transit', 'Access', 'Interaction', 'HouseRules',
'ThumbnailURL', 'MediumURL', 'PictureURL', 'XLPictureURL', 'HostID',
'HostURL', 'HostName', 'HostSince', 'HostLocation', 'HostAbout',
'HostResponseTime', 'HostResponseRate', 'HostAcceptanceRate',
'HostIsSuperhost', 'HostThumbnailURL', 'HostPictureURL', 'HostNeighborhood',
'HostListingsCount', 'HostTotalListingsCount', 'HostVerifications',
'HostHasProfilePic', 'HostIdentityVerified', 'Street', 'Neighborhood',
'NeighborhoodCleansed', 'NeighborhoodGroupCleansed', 'City', 'State',
'ZipCode', 'Market', 'SmartLocation', 'CountryCode', 'Country', 'Latitude',
'Longitude', 'IsLocationExact', 'PropertyType', 'RoomType', 'Accommodates',
'Bathrooms', 'Bedrooms', 'Beds', 'BedType', 'Amenities', 'SquareFeet', 'Price',
'WeeklyPrice', 'MonthlyPrice', 'SecurityDeposit', 'CleaningFee',
'GuestsIncluded', 'ExtraPeople', 'MinimumNights', 'MaximumNights',
'CalendarUpdated', 'HasAvailability', 'Availability30', 'Availability60',
'Availability90', 'Availability365', 'CalendarLastScraped', 'NumberOfReviews',
'FirstReview', 'LastReview', 'ReviewScoresRating', 'ReviewScoresAccuracy',
'ReviewScoresCleanliness', 'ReviewScoresCheckIn', 'ReviewScoresCommunication',
'ReviewScoresLocation', 'ReviewScoresValue', 'RequiresLicense', 'License',
'JurisdictionNames', 'InstantBookable', 'CancellationPolicy',
'RequireGuestProfilePicture', 'RequireGuestPhoneVerification', 'RegionID',
'RegionName', 'RegionParentID', 'CalculatedHostListingsCount',
'ReviewsPerMonth')
# Combine gz file data source and SQLite column names for listings data into mapping data frame
listings_df_colnames <- data.frame(listings_ds_colnames, listings_db_colnames)
# Find max data scrape mapping ID already in the SQLite database
max_scrape <- dbExecute(abnb_db, 'SELECT MAX(DataScrape_ID) FROM Map_DataScrape;')
# Directory for data folder
data_directory <- 'C:/Airbnb'
# Directory and file for SQLite database
sqlite_directory <- 'C:/SQLite/Databases/Airbnb.sqlite3'
# Connect to or create SQLite database
abnb_db <- dbConnect(SQLite(), sqlite_directory)
# Find max data scrape mapping ID already in the SQLite database
max_scrape <- dbExecute(abnb_db, 'SELECT MAX(DataScrape_ID) FROM Map_DataScrape;')
# Read listings data and populate into SQLite database
loop <- 1 + max_scrape
while (loop <= (max_scrape + nrow(dir_df))) {
# Repair columns if broken
listings_temp <- readLines(paste(data_directory, '/', dir_df[loop, 1], '/',
dir_df[loop, 2], '/', dir_df[loop, 3], '/',
dir_df[loop, 4], '/listings.csv.gz', sep = ''))
# Fix quoting characters and replace two consecutive double quotes with a single quote
listings_temp <- gsub(',\'"', ',"\'', gsub('""', '\'', listings_temp))
# Write temp data to temporary file
write(listings_temp, file = 'temp.txt', ncolumns = 1)
# Prepare listings data frame
listings <- read.table('temp.txt', sep = ',', quote = '"', header = TRUE, comment.char = '',
stringsAsFactors = FALSE)
# Remove NAs (interpreted as NULL)
listings[is.na(listings)] <- ''
# Create extra data rows
lst_length <- nrow(listings)
id_vec_lst <- rep(NA, lst_length)
map_id_vec_lst <- rep(loop, lst_length)
# Add extra data rows to data frame
listings['Listings_ID'] <- id_vec_lst
listings['DataScrape_ID'] <- map_id_vec_lst
# Set column names
i <- 1
while (i <= length(names(listings))) {
names(listings)[i] <- as.character(listings_df_colnames$listings_db_colnames
[match(names(listings)[i],
listings_df_colnames$listings_ds_colnames)])
i <- i + 1
}
# Fill in missing columns with NA
i <- 1
while (i <= length(listings_df_colnames$listings_db_colnames)) {
if (!is.element(listings_df_colnames$listings_db_colnames[i], names(listings))) {
temp_vec <- rep(NA, lst_length)
listings[as.character(listings_df_colnames$listings_db_colnames[i])] <- temp_vec
}
i <- i + 1
}
# Reorder data frame
i <- 1
name_vec <- vector(mode = 'integer')
while (i <= length(listings_df_colnames$listings_db_colnames)) {
name_vec[i] <- match(listings_df_colnames$listings_db_colnames[i], names(listings))
i <- i + 1
}
listings <- listings[name_vec]
# Strip dollar signs and commas from prices
listings$Price <- gsub(',', '', gsub('\\$', '', listings$Price))
listings$WeeklyPrice <- gsub(',', '', gsub('\\$', '', listings$WeeklyPrice))
listings$MonthlyPrice <- gsub(',', '', gsub('\\$', '', listings$MonthlyPrice))
listings$SecurityDeposit <- gsub(',', '', gsub('\\$', '', listings$SecurityDeposit))
listings$CleaningFee <- gsub(',', '', gsub('\\$', '', listings$CleaningFee))
listings$ExtraPeople <- gsub(',', '', gsub('\\$', '', listings$ExtraPeople))
# Strip percent signs
listings$HostResponseRate <- gsub('%', '', listings$HostResponseRate)
listings$HostAcceptanceRate <- gsub('%', '', listings$HostAcceptanceRate)
# Write listings data frame to SQLite database
dbWriteTable(abnb_db, name = 'Listings', value = listings, append = TRUE)
# Increment loop
loop <- loop + 1
}
dir_vec <- list.files(data_directory, recursive = TRUE)
dir_df <- t(data.frame(strsplit(dir_vec, split = '/'), stringsAsFactors = FALSE))
dir_df <- unique(dir_df[, 1:4])
colnames(dir_df) <- c('Country', 'State', 'City', 'DataScrapeDate')
rownames(dir_df) <- seq.int(1, nrow(dir_df))
head(dir_df, 10)
# Read listings data and populate into SQLite database
loop <- 1 + max_scrape
while (loop <= (max_scrape + nrow(dir_df))) {
# Repair columns if broken
listings_temp <- readLines(paste(data_directory, '/', dir_df[loop, 1], '/',
dir_df[loop, 2], '/', dir_df[loop, 3], '/',
dir_df[loop, 4], '/listings.csv.gz', sep = ''))
# Fix quoting characters and replace two consecutive double quotes with a single quote
listings_temp <- gsub(',\'"', ',"\'', gsub('""', '\'', listings_temp))
# Write temp data to temporary file
write(listings_temp, file = 'temp.txt', ncolumns = 1)
# Prepare listings data frame
listings <- read.table('temp.txt', sep = ',', quote = '"', header = TRUE, comment.char = '',
stringsAsFactors = FALSE)
# Remove NAs (interpreted as NULL)
listings[is.na(listings)] <- ''
# Create extra data rows
lst_length <- nrow(listings)
id_vec_lst <- rep(NA, lst_length)
map_id_vec_lst <- rep(loop, lst_length)
# Add extra data rows to data frame
listings['Listings_ID'] <- id_vec_lst
listings['DataScrape_ID'] <- map_id_vec_lst
# Set column names
i <- 1
while (i <= length(names(listings))) {
names(listings)[i] <- as.character(listings_df_colnames$listings_db_colnames
[match(names(listings)[i],
listings_df_colnames$listings_ds_colnames)])
i <- i + 1
}
# Fill in missing columns with NA
i <- 1
while (i <= length(listings_df_colnames$listings_db_colnames)) {
if (!is.element(listings_df_colnames$listings_db_colnames[i], names(listings))) {
temp_vec <- rep(NA, lst_length)
listings[as.character(listings_df_colnames$listings_db_colnames[i])] <- temp_vec
}
i <- i + 1
}
# Reorder data frame
i <- 1
name_vec <- vector(mode = 'integer')
while (i <= length(listings_df_colnames$listings_db_colnames)) {
name_vec[i] <- match(listings_df_colnames$listings_db_colnames[i], names(listings))
i <- i + 1
}
listings <- listings[name_vec]
# Strip dollar signs and commas from prices
listings$Price <- gsub(',', '', gsub('\\$', '', listings$Price))
listings$WeeklyPrice <- gsub(',', '', gsub('\\$', '', listings$WeeklyPrice))
listings$MonthlyPrice <- gsub(',', '', gsub('\\$', '', listings$MonthlyPrice))
listings$SecurityDeposit <- gsub(',', '', gsub('\\$', '', listings$SecurityDeposit))
listings$CleaningFee <- gsub(',', '', gsub('\\$', '', listings$CleaningFee))
listings$ExtraPeople <- gsub(',', '', gsub('\\$', '', listings$ExtraPeople))
# Strip percent signs
listings$HostResponseRate <- gsub('%', '', listings$HostResponseRate)
listings$HostAcceptanceRate <- gsub('%', '', listings$HostAcceptanceRate)
# Write listings data frame to SQLite database
dbWriteTable(abnb_db, name = 'Listings', value = listings, append = TRUE)
# Increment loop
loop <- loop + 1
}
if (exists(calendar_temp)) {rm(calendar_temp)}
exists(calendar_temp)
?exists
exists('calendar_temp')
exists('abnb_db')
rm(loop)
exists(lst_length)
rm(lst_length)
rM(listings_temp)
rm(listings_temp)
rm(listings)
# Disconnect from SQLite database
dbDisconnect(abnb_db)
getwd()
?SQLite
?dbExistsTable
# Directory for data folder
data_directory <- 'C:/Airbnb'
# Directory and file for SQLite database
sqlite_directory <- 'C:/SQLite/Databases/Airbnb.sqlite3'
# Connect to or create SQLite database
abnb_db <- dbConnect(SQLite(), sqlite_directory)
library(RSQLite)
library(DBI)
# Connect to or create SQLite database
abnb_db <- dbConnect(SQLite(), sqlite_directory)
dbExecute(abnbdb, 'SELECT * FROM Calendar LIMIT 5')
# Connect to or create SQLite database
abnb_db <- dbConnect(SQLite(), sqlite_directory)
# Connect to or create SQLite database
dbExecute(abnbdb, 'SELECT * FROM Calendar LIMIT 5')
dbExecute(abnb_db, 'SELECT * FROM Calendar LIMIT 5')
?RSQLite
dbSendQuery(abnb_db, 'SELECT * FROM Calendar LIMIT 5')
dbFetch(dbSendQuery(abnb_db, 'SELECT * FROM Calendar LIMIT 5'))
install.packages(RMySQL)
install.packages('RMySQL'')
''
install.packages('RMySQL')
# Disconnect from SQLite database
dbDisconnect(abnb_db)
dbClearResults(abnb_db)
